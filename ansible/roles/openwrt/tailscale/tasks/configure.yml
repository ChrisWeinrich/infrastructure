---
# Capture current Tailscale status for idempotent configuration.
- name: Read Tailscale status
  ansible.builtin.raw: "tailscale status --json"
  register: tailscale_status
  changed_when: false
  failed_when: false

# Enable the Tailscale UCI config to keep service enabled across reboots.
- name: Ensure Tailscale UCI is enabled
  ansible.builtin.raw: |
    enabled="$(uci -q get tailscale.settings.enabled || echo 0)"
    if [ "$enabled" != "1" ]; then
      uci set tailscale.settings.enabled='1'
      uci commit tailscale
      echo changed
    fi
  register: tailscale_uci_enable
  changed_when: "'changed' in tailscale_uci_enable.stdout"

# Make sure the daemon is running before running `tailscale up`.
- name: Ensure Tailscale service is running before configuration
  ansible.builtin.raw: |
    if [ -x /etc/init.d/tailscale ]; then
      /etc/init.d/tailscale enable
      /etc/init.d/tailscale restart
    fi
  changed_when: false

# Decide if `tailscale up` must be re-run based on status or routes.
- name: Determine if Tailscale configuration is needed
  ansible.builtin.set_fact:
    tailscale_needs_up: >-
      {{ tailscale_status.rc != 0 or
      '"BackendState":"Running"' not in tailscale_status.stdout or
      (openwrt_tailscale_routes | join(',')) not in tailscale_status.stdout }}

# Apply auth key and advertised routes when configuration is needed.
- name: Configure Tailscale routes
  ansible.builtin.raw: >-
    tailscale up
    --authkey {{ openwrt_tailscale_authkey }}
    --advertise-routes={{ openwrt_tailscale_routes | join(',') }}
    --accept-dns={{ 'true' if (openwrt_tailscale_accept_dns | default(false)) else 'false' }}
    {{ '--accept-routes' if (openwrt_tailscale_accept_routes | default(true)) else '--accept-routes=false' }}
  when: tailscale_needs_up | bool
  register: tailscale_up
  changed_when: true
  no_log: "{{ openwrt_tailscale_no_log | default(true) }}"
